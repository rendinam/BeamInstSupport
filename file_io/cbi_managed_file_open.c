/*!-----------------------------------------------------------------------+
* File         :  cbi_managed_file_open.c                                 |
*                                                                         |
* Description  :  Opens an output file for data writing in a managed way. |
*                 If the file index has not yet been assigned, this will  |
*                 create a new file using that index in the correct       |
*                 single or multi-instrument mode and calls the file      |
*                 header writing function.                                |
*                                                                         |
*                 If a file index has already been assigned, this will    |
*                 simple open the file for appending and allow new data   |
*                 be directed into it.                                    |
*                                                                         |
* Arguments    :  -Pointer to string that holds the file name after the   |
*                  call is complete                                       |
*                 -Pointer to string that holds the full path and file    |
*                  name after the call is complete                        |
*                 -Index of instrument                                    |
*                 -Integer specifying the directory in which to create    |
*                  the file.                                              |
*                 -Integer specifying the type of the file to write,      |
*                  determines the header contents and other specifics.    |
*                 -Integer flag specifying the 'multiplicity' type of the |
*                  file to be written.  CBI_MULTI_FILE means each         |
*                  instrument will write its output to an individualized  |
*                  file.  CBI_SINGLE_FILE means all instruments will      |
*                  write their output to the same file.                   |
*                 -Integer flag specifying whether or not the file to be  |
*                  written is a 'supplemental' file, meaning a file with  |
*                  unique content, but sharing the same index value as    |
*                  other files generated by the measurement.              |
*                                                                         |
* Author       :  M. Rendina                                              |
*-------------------------------------------------------------------------+*/

#include "cbi_core_includes.h"


#define CBIC_FILE_OPEN_ATTEMPTS    4


int file_subdir( int file_idx, char *subdir_string ) {
  
  int subdir_val;

  // Determine target directory number
  subdir_val = file_idx / CBI_FILES_PER_DIR;
  if (subdir_val < 100) {
    sprintf( subdir_string, "%02d/", subdir_val );
  } else {
    sprintf( subdir_string, "%03d/", subdir_val );
  }
  sprintf( subdir_string, "%02d/", subdir_val );
  
  return CBI_F_SUCCESS;

}






FILE* cbi_managed_file_open( char *filename, char *full_fname, int iidx, int dirspec, int filetype, int multiplicity, int supplemental ) {

  char *func_name = (char *)__FUNCTION__;
  
  FILE *fp = NULL;
  int file_idx;
  int attempt;

  struct stat statbuf; // For file existence checking
  char subdir_string[6] = "";

  RDV3_FILE_HEADER hdata;
  RDV3_CESR_HEADER cdata;


  ////// FIXME: KLUDGE: Fix for race condition if two concurrently running servers
  // finish at nearly the exact same time and pick up the same file index
  // value before one has a chance to bump it.
  printf("MailboxID = %d\n", CTL_CBPM_Intf_Monitor.MailboxID);
  if (CTL_CBPM_Intf_Monitor.MailboxID == 1) {
    sleep(2);
  }

  //--------------------------------------------
  // Only bump index for the target directory 
  // if single-file output is requested and if
  // this is the first instrument in the 
  // iteration.
  //--------------------------------------------
  if (CTL_System.output_file_index == CBI_FILE_ID_NOT_SET) {

    file_idx     = cbi_new_file_idx(dirspec, TRUE);
    CTL_System.output_file_index = file_idx;

    if (multiplicity == CBI_MULTI_FILE) {
      cbi_datafile_name(filetype, filename, iidx, file_idx);
    } else {
      cbi_datafile_name_single(filetype, filename, file_idx);
    }

    strcat( full_fname, appconfig.directories[dirspec] );
    strcat( full_fname, "/" );


    // Determine target directory number
    file_subdir( file_idx, subdir_string );

    strcat( full_fname, subdir_string );

    // See if the target directory exists yet
    if ( stat(full_fname, &statbuf) == -1 ) {
      printf("Configured to sort output files by index in\n");
      printf("groups of %d.\n", CBI_FILES_PER_DIR);
      printf("Creating new output directory \'%s\'\n", full_fname);
      mkdir( full_fname, 0777 );
    }


    strcat( full_fname, filename );
  
    attempt = 0;
    while ( fp == NULL && attempt < CBIC_FILE_OPEN_ATTEMPTS ) {
      fp = fopen(full_fname, "w");  // Creates file
      fclose(fp);
      fp = fopen(full_fname, "r+"); // Re-opens allowing for reading and
      attempt++;                    // modification later, if necessary.
      if (fp == NULL) {
	sprintf( message, "file %s could not be opened!\n", full_fname);
	log_message( S_ERROR, func_name, message );
      }
    }
    

    if (filetype != PARAMETERS) {
      cbi_prep_datafile_header(&hdata, filetype, iidx, file_idx);
      cbpmfio_rw_file_header(fp, CBPMFIO_WRITE);

      cbi_prep_cesr_header(&cdata);
      cbpmfio_rw_cesr_header(fp, CBPMFIO_WRITE);
    }


    // For PARAMETER FILE intermediate writes, COPY the master file
    // to the newly-created intermediate file (file with index #)
    if (filetype == PARAMETERS) {
      FILE *fps = fopen( appconfig.inst_param_file, "r" );
      if (fps == NULL) {
	perror("Error opening instrument constants file... ");
	return NULL;
      }
      cbi_copy_file_by_ptr(fp, fps);
      fclose(fps);
    }
    


  } else {

    file_idx = CTL_System.output_file_index;

    if (multiplicity == CBI_MULTI_FILE) {
      cbi_datafile_name(filetype, filename, iidx, file_idx);
    } else {
      cbi_datafile_name_single(filetype, filename, file_idx);
    }

    strcat( full_fname, appconfig.directories[dirspec] );
    strcat( full_fname, "/" );


    // Determine target directory number
    file_subdir( file_idx, subdir_string );

    strcat( full_fname, subdir_string );


    strcat( full_fname, filename );

    attempt = 0;
    while ( fp == NULL && attempt < CBIC_FILE_OPEN_ATTEMPTS ) {
      if (filetype == PARAMETERS) {
	fp = fopen(full_fname, "r+");
      }else {
	fp = fopen(full_fname, "a+");
      }
      attempt++;
      if (fp == NULL) {
	sprintf( message, "file %s could not be opened!\n", full_fname);
	log_message( S_ERROR, func_name, message );
      }
    }
    if (fp == NULL) {
      sprintf(message, "All %d attempts to open file %s have failed!\n", CBIC_FILE_OPEN_ATTEMPTS, full_fname);
      log_message( S_ERROR, func_name, message );
    }

    
    if (multiplicity == CBI_MULTI_FILE || supplemental == TRUE) {

      cbi_prep_datafile_header(&hdata, filetype, iidx, file_idx);
      cbpmfio_rw_file_header(fp, CBPMFIO_WRITE);
      cbi_prep_cesr_header(&cdata);
      cbpmfio_rw_cesr_header(fp, CBPMFIO_WRITE);

    }

  } //endIF CTL_System.output_file_index

  return fp;
}






FILE* cbi_managed_file_open_fixedindex( char *filename, char *full_fname, int iidx, int dirspec, int filetype) {

  char *func_name = (char *)__FUNCTION__;
  
  FILE *fp = NULL;
  int file_idx;
  int attempt;

  struct stat statbuf; // For file existence checking
  char subdir_string[6] = "";

  file_idx = CTL_System.output_file_index;
  cbi_datafile_name(CHAN_CAL, filename, iidx, CTL_System.output_file_index);
  
  strcat( full_fname, appconfig.directories[TSCAN_DIR] );
  strcat( full_fname, "/" );
  
  // Determine target directory number
  file_subdir( file_idx, subdir_string );

  strcat( full_fname, subdir_string );

  // See if the target directory exists yet
  if ( stat(full_fname, &statbuf) == -1 ) {
    printf("Configured to sort output files by index in\n");
    printf("groups of %d.\n", CBI_FILES_PER_DIR);
    printf("Creating new output directory \'%s\'\n", full_fname);
    mkdir( full_fname, 0777 );
  }

  strcat( full_fname, filename );

  attempt = 0;
  fp = NULL;
  while ( fp == NULL && attempt < 2 ) {
    fp = fopen(full_fname, "w");  // Creates file
    fclose(fp);
    fp = fopen(full_fname, "r+"); // Re-opens allowing for reading and
    attempt++;                    // modification later, if necessary.
    if (fp == NULL) {
      sprintf( message, "file %s could not be opened!\n", full_fname);
      log_message( S_ERROR, func_name, message );
    }
  }
  if (fp == NULL) {
    sprintf(message, "All %d attempts to open file %s have failed!\n", 2, full_fname);
    log_message( S_ERROR, func_name, message );
  }

  return fp;

}
