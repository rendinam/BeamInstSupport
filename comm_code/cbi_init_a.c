
//------------------------------------------------------------------------
//  D O     N O T     E D I T     T H I S     F I L E
//------------------------------------------------------------------------
// File         :  cbi_init_a.c
// Date Created :  Fri Sep 14 14:07:50 2012
//
// Description  :  This file was automatically generated by the BIParser.
//                 It initializes one instrument's worth of communication
//                 data structures for a particular platform.
//                 This routine is for CONTROL application usage only.
//------------------------------------------------------------------------

// ACC System Includes
#include "CESR_platform.h"
#include "utilities.h"

#define CBI_NO_EXTERN

#include "cbi_core_includes.h"
#include "cbi_config_a.h"




int cbi_init_a(CBI_CTL_MODULE *p_ctl_mod) {
  int i, first_tag, num_tags, tag;
  COMM_KEY *p_key;

  CBI_DATA* p_core;
  p_core=p_ctl_mod->core;
  CBI_DETECTOR detector_init;
  p_ctl_mod->active     = CBI_INACTIVE;
  p_ctl_mod->db_update  = CBI_DONT_UPDATE;

  //Initialize p_ctl_mod->mod
  //Initialize p_ctl_mod->det
  p_ctl_mod->det = detector_init;

  //Initialize p_ctl_mod->dsp_data
  p_ctl_mod->dsp_data = NULL;

  //Initialize p_ctl_mod->analysis
  p_ctl_mod->analysis = NULL;
  p_ctl_mod->n_keys = 0;


//---Initializations for cbi_cmd
  p_key = &(p_ctl_mod->key[p_ctl_mod->n_keys]);
  // configuration
  p_key->p_config      = &(cbi_cmd_cfg);
  //data pointers
  p_key->data.ptr[ 0]  = (void *)(&(p_core->cbi_cmd.cmd));
  p_key->data.ptr[ 1]  = (void *)(&(p_core->cbi_cmd.cmd_status));
  p_key->data.ptr[ 2]  = (void *)(&(p_core->cbi_cmd.error[0]));
  p_key->data.ptr[ 3]  = (void *)(&(p_core->cbi_cmd.handshake));
  // tag2key_map
  first_tag = p_key->p_config->struct_tag;
  num_tags  = p_key->p_config->num_pkts;
  for (tag = first_tag; tag < (first_tag + num_tags); tag++) {
    p_ctl_mod->tag2key_map[tag] = p_ctl_mod->n_keys;
  }
  p_ctl_mod->n_keys++;



//---Initializations for cbi_stat
  p_key = &(p_ctl_mod->key[p_ctl_mod->n_keys]);
  // configuration
  p_key->p_config      = &(cbi_stat_cfg);
  //data pointers
  p_key->data.ptr[ 0]  = (void *)(&(p_core->cbi_stat.state));
  p_key->data.ptr[ 1]  = (void *)(&(p_core->cbi_stat.status));
  p_key->data.ptr[ 2]  = (void *)(&(p_core->cbi_stat.num_levels));
  p_key->data.ptr[ 3]  = (void *)(&(p_core->cbi_stat.trace[0]));
  // tag2key_map
  first_tag = p_key->p_config->struct_tag;
  num_tags  = p_key->p_config->num_pkts;
  for (tag = first_tag; tag < (first_tag + num_tags); tag++) {
    p_ctl_mod->tag2key_map[tag] = p_ctl_mod->n_keys;
  }
  p_ctl_mod->n_keys++;



//---Initializations for cbi_debug
  p_key = &(p_ctl_mod->key[p_ctl_mod->n_keys]);
  // configuration
  p_key->p_config      = &(cbi_debug_cfg);
  //data pointers
  p_key->data.ptr[ 0]  = (void *)(&(p_core->cbi_debug.write_ptr));
  p_key->data.ptr[ 1]  = (void *)(&(p_core->cbi_debug.debug[0]));
  p_key->data.ptr[ 2]  = (void *)(&(p_core->cbi_debug.routine[0]));
  p_key->data.ptr[ 3]  = (void *)(&(p_core->cbi_debug.padding));
  // tag2key_map
  first_tag = p_key->p_config->struct_tag;
  num_tags  = p_key->p_config->num_pkts;
  for (tag = first_tag; tag < (first_tag + num_tags); tag++) {
    p_ctl_mod->tag2key_map[tag] = p_ctl_mod->n_keys;
  }
  p_ctl_mod->n_keys++;



//---Initializations for cbi_ident
  p_key = &(p_ctl_mod->key[p_ctl_mod->n_keys]);
  // configuration
  p_key->p_config      = &(cbi_ident_cfg);
  //data pointers
  p_key->data.ptr[ 0]  = (void *)(&(p_core->cbi_ident.ipaddr[0]));
  p_key->data.ptr[ 1]  = (void *)(&(p_core->cbi_ident.hostname[0]));
  p_key->data.ptr[ 2]  = (void *)(&(p_core->cbi_ident.module_type));
  p_key->data.ptr[ 3]  = (void *)(&(p_core->cbi_ident.fpga_maj));
  p_key->data.ptr[ 4]  = (void *)(&(p_core->cbi_ident.fpga_min));
  p_key->data.ptr[ 5]  = (void *)(&(p_core->cbi_ident.fe_fpga_id[0]));
  // tag2key_map
  first_tag = p_key->p_config->struct_tag;
  num_tags  = p_key->p_config->num_pkts;
  for (tag = first_tag; tag < (first_tag + num_tags); tag++) {
    p_ctl_mod->tag2key_map[tag] = p_ctl_mod->n_keys;
  }
  p_ctl_mod->n_keys++;



//---Initializations for cbi_heartbeat
  p_key = &(p_ctl_mod->key[p_ctl_mod->n_keys]);
  // configuration
  p_key->p_config      = &(cbi_heartbeat_cfg);
  //data pointers
  p_key->data.ptr[ 0]  = (void *)(&(p_core->cbi_heartbeat.heartbeat));
  p_key->data.ptr[ 1]  = (void *)(&(p_core->cbi_heartbeat.timing_integrity));
  p_key->data.ptr[ 2]  = (void *)(&(p_core->cbi_heartbeat.turns_seen));
  // tag2key_map
  first_tag = p_key->p_config->struct_tag;
  num_tags  = p_key->p_config->num_pkts;
  for (tag = first_tag; tag < (first_tag + num_tags); tag++) {
    p_ctl_mod->tag2key_map[tag] = p_ctl_mod->n_keys;
  }
  p_ctl_mod->n_keys++;



//---Initializations for cbi_module_config
  p_key = &(p_ctl_mod->key[p_ctl_mod->n_keys]);
  // configuration
  p_key->p_config      = &(cbi_module_config_cfg);
  //data pointers
  p_key->data.ptr[ 0]  = (void *)(&(p_core->cbi_module_config.exe_type));
  p_key->data.ptr[ 1]  = (void *)(&(p_core->cbi_module_config.exe_version));
  p_key->data.ptr[ 2]  = (void *)(&(p_core->cbi_module_config.ldr_name[0]));
  p_key->data.ptr[ 3]  = (void *)(&(p_core->cbi_module_config.build_timestamp));
  p_key->data.ptr[ 4]  = (void *)(&(p_core->cbi_module_config.core_comm_struct_rev));
  p_key->data.ptr[ 5]  = (void *)(&(p_core->cbi_module_config.platform_comm_struct_rev));
  p_key->data.ptr[ 6]  = (void *)(&(p_core->cbi_module_config.compiler_ver));
  p_key->data.ptr[ 7]  = (void *)(&(p_core->cbi_module_config.lib_version));
  p_key->data.ptr[ 8]  = (void *)(&(p_core->cbi_module_config.hardware_ver));
  p_key->data.ptr[ 9]  = (void *)(&(p_core->cbi_module_config.firmware_ver));
  // tag2key_map
  first_tag = p_key->p_config->struct_tag;
  num_tags  = p_key->p_config->num_pkts;
  for (tag = first_tag; tag < (first_tag + num_tags); tag++) {
    p_ctl_mod->tag2key_map[tag] = p_ctl_mod->n_keys;
  }
  p_ctl_mod->n_keys++;



  return F_SUCCESS;
}
